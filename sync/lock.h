//
// Created by kingdo on 2020/10/24.
//

#ifndef TPFAAS_LOCK_H
#define TPFAAS_LOCK_H

#define INIT_LOCK() init_all_lock();

/**
 *
 * 规避死锁:不要在锁中套锁,那么一定不会死锁
 *
 * 所有需要锁的位置:
 *
 * 一.F的全局I队列&&F的剩余容量&&正在等待的I数目:
 *      1. 当有新的请求产生,将I加入队列的时
 *      2. 当T从F中拉取I时
 * 二.T的本地队列&&队列任务数:
 *      1. 从本地队列去一个I来运行时
 *      2. 从F的全局I队列偷任务时
 *      3. 被人来偷自己队列上的I任务时
 *
 * 三.R的空闲T列表&&队列任务数
 *      1. R的忙碌T结束任务且没有I可以执行时,加入到空闲链表
 *      2. F唤醒一个空闲的T来执行,会寻找任务来执行,一旦找到就会脱离idle队列追加到busy队列以及F的T列表
 * 四.R的忙碌T列表&&队列任务数
 *      1. 一个T被唤醒后找到了可执行任务,脱离idle队列追加到busy队列
 *      2. R的忙碌T结束任务且没有I可以执行时,脱离idle队列追加到busy队列
 * 五.F的T列表
 *      1. R的忙碌T结束任务且没有I可以执行时,加入到空闲链表的同时也会从F的T链表中移除
 *      2. 一个T被唤醒后找到了可执行任务,脱离idle队列追加到追加到busy队列以及F的T列表
 * */

/***
 *
 * 
 *
 *
 * */


//初始化所有的锁
static inline void init_all_lock() {

}

#endif //TPFAAS_LOCK_H
